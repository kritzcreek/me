(in-package :cl-user)
(defpackage two
  (:use :cl))
(in-package :two)

;; Each new term in the Fibonacci sequence is generated by adding the previous
;; two terms. By starting with 1 and 2, the first 10 terms will be:
;;
;; 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
;;
;; By considering the terms in the Fibonacci sequence whose values do not exceed
;; four million, find the sum of the even-valued terms.


(set 'phi (/ (+ 1 (sqrt 5)) 2))
(set 'psy (/ (- 1 (sqrt 5)) 2))

(defun fibonacci (n)
  "Naive Fibonacci implementation:

   F_n = F_{n-1} + F_{n-2}, F_1=1, F_2=2"
  (if (< n 2)
      n
      (+ (fibonacci (- n 1))
	 (fibonacci (- n 2)))))

(defun binet-fibonacci (n)
  (/ (- (expt phi n)
	(expt (- phi)
	      (- n)))
     (sqrt 5)))

(defun square (n)
  "Convenience function for taking a number n to it's second power."
  (expt n 2))

(defun squarep (n)
  "Basic perfect square predicate."
  (= (square (isqrt n)) n))

(defun reverse-fibonaccip (n)
  "A number n is a Fibonacci number if one or both of 5n^2+4 or 5n^2-4 is a
  perfect square (Gessel, 1972, _The Fibonacci Quarterly_)."
  (let* ((fn  (lambda (x) (* 5 (expt x 2))))
	 (pos (+ (funcall fn n) 4))
	 (neg (- (funcall fn n) 4)))
    (or (squarep pos)
	(squarep neg))))

(defun reverse-fibonacci (n)
  "Binet's formula for Fibonacci numbers can be rearranged as:

  n=log_{\phi}(\frac{F_n\sqrt{5}+\sqrt{5F_n^2+4}}{2})

  where

  \phi = \frac{1+\sqrt{5}}{2} \approx 1.6180339887...

  is the golden ratio, and

  \psy = \frac{1-\sqrt{5}}{2} = 1-\phi = -\frac{1}{phi} \approx -0.6180339887..."
  (if (reverse-fibonaccip n)
      (log (/ (+ (* (fibonacci n)
		    (sqrt 5))
		 (sqrt (* 5
			  (+ (square (fibonacci n))
			     4))))
	      2)
	   phi)
      nil))


;; almost there, now I just need to take the reverse fibonacci down from 4M, then...
;; or better yet, loop fibonacci until output reaches 4M, then..
;; (if (evenp n) sum all n's)  <- thats pseudocode, but I get the idea



;; it might be useful to learn how to properly convert number types
