#+title: Euler problems
#+author: Ben Sima <bensima@gmail.com>

[[file:euler.jpg]]

Am I a mathematician yet?

* DONE Problem 1 - Multiples of 3 and 5
CLOSED: [2015-11-06 Fri 16:45]

If we list all the natural numbers below 10 that are multiples of 3 or 5, we get
3, 5, 6 and 9. The sum of these multiples is 23.

Find the sum of all the multiples of 3 or 5 below 1000.

** DONE Haskell
CLOSED: [2015-11-06 Fri 16:43]

#+BEGIN_SRC haskell
sum [3, 6..999] + sum[5, 10..999] - sum[15, 30..999]
#+END_SRC

** DONE Common Lisp
CLOSED: [2015-11-06 Fri 16:45]

#+BEGIN_SRC common-lisp
(defun collector (n)
  (if (or (= 0 (mod n 5))
          (= 0 (mod n 3)))
      n
      0))

(defun one (n)
  "Returns the sum of all multiples of 3 or 5 < n which satisfy c."
  (reduce #'+ (loop for i from 0 to n collect (collector i))))

(one 999)
#+END_SRC

* TODO Problem 2 - Even Fibonacci numbers

Each new term in the Fibonacci sequence is generated by adding the previous two
terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed
four million, find the sum of the even-valued terms.

** TODO Common Lisp

Old, over-engineered attempt:

#+BEGIN_SRC common-lisp
(set 'phi (/ (+ 1 (sqrt 5)) 2))
(set 'psy (/ (- 1 (sqrt 5)) 2))

(defun fibonacci (n)
  "Naive Fibonacci implementation:

   F_n = F_{n-1} + F_{n-2}, F_1=1, F_2=2"
  (if (< n 2)
      n
      (+ (fibonacci (- n 1))
   (fibonacci (- n 2)))))

(defun binet-fibonacci (n)
  (/ (- (expt phi n)
  (expt (- phi)
        (- n)))
     (sqrt 5)))

(defun square (n)
  "Convenience function for taking a number n to it's second power."
  (expt n 2))

(defun squarep (n)
  "Basic perfect square predicate."
  (= (square (isqrt n)) n))

(defun reverse-fibonaccip (n)
  "A number n is a Fibonacci number if one or both of 5n^2+4 or 5n^2-4 is a
  perfect square (Gessel, 1972, _The Fibonacci Quarterly_)."
  (let* ((fn  (lambda (x) (* 5 (expt x 2))))
   (pos (+ (funcall fn n) 4))
   (neg (- (funcall fn n) 4)))
    (or (squarep pos)
  (squarep neg))))

(defun reverse-fibonacci (n)
  "Binet's formula for Fibonacci numbers can be rearranged as:

  n=log_{\phi}(\frac{F_n\sqrt{5}+\sqrt{5F_n^2+4}}{2})

  where

  \phi = \frac{1+\sqrt{5}}{2} \approx 1.6180339887...

  is the golden ratio, and

  \psy = \frac{1-\sqrt{5}}{2} = 1-\phi = -\frac{1}{phi} \approx -0.6180339887..."
  (if (reverse-fibonaccip n)
      (log (/ (+ (* (fibonacci n)
        (sqrt 5))
     (sqrt (* 5
        (+ (square (fibonacci n))
            4))))
        2)
     phi)
      nil))
#+END_SRC

Almost there, now I just need to take the reverse fibonacci down from 4M,
then... or better yet, loop =fibonacci= until output reaches 4M, then.. =(if
(evenp n) sum all n's)= <- thats pseudocode, but I get the idea

** TODO OCaml

#+BEGIN_SRC ocaml
let rec fib =
  match n with
  | (0 | 1) -> 1
  | x when x > 0 -> (fib (x-2) + fib (x-1))
  | _ -> raise (Invalid_argument "Negative value supplied to fib")
#+END_SRC

** DONE Haskell
CLOSED: [2016-01-15 Fri 19:19]

#+BEGIN_SRC haskell
  -- Calculate fibonacci sequence
  fibs :: Num a => [a]
  fibs = 1 : 2 : zipwith (+) fibs (tail fibs)

  -- list comprehension: creates a list of all x where x is the result of the
  -- function `fibs' less than 4,000,000 and `even x'
  sum [x | x <- takeWhile (< 4000000) fibs, even x]
#+END_SRC

* Problem 3 - Largest Prime Factors

** Pseudocode

The trial-by-division method

#+BEGIN_EXAMPLE
define factors(n):
    z = 2
    while (z * z <= n):
        if (n % z == 0):
            output z
            n /= z
        else:
            z++
    if n > 1
        output n
#+END_EXAMPLE
